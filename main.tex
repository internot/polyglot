\documentclass[10pt, conference, compsocconf]{IEEEtran}

\usepackage{listings}

\title{Crossing Origins by Crossing Formats}

\begin{document}


% \author{\IEEEauthorblockN{Jonas Magazinius} 
% \IEEEauthorblockA{Department ofComputer Science\\ 
% Chalmers University of Technology\\ 
% Gothenburg, Sweden\\
% jonas.magazinius@chalmers.se} 
% \and 
% \IEEEauthorblockN{Billy Rios} 
% \IEEEauthorblockA{dept. name of organization\\ 
% name of organization, acronyms acceptable\\ 
% City, United States of America\\ 
% Email: name@xyz.com} 
% \and 
% \IEEEauthorblockN{Andrei Sabelfeld} 
% \IEEEauthorblockA{Department of Computer Science\\ 
% Chalmers University of Technology\\ 
% Gothenburg, Sweden\\ 
% andrei@chalmers.se} 
% }

\maketitle



\begin{abstract}
 In a heterogeneous system like the web, information is
exchanged between components in versatile formats. A new breed of attacks is on
the rise that exploit the mismatch between the expected and provided content.
\emph{Injection attacks} are becoming increasingly more sophisticated by
operating across multiple languages. \emph{Content repurposing} attacks supply
malicious payload that appears formatted as benign content. 
% 
This paper focuses on the root cause of a large class of attacks: \emph{polyglots}. 
A polyglot is a program that is valid in multiple programming languages. Polyglots allow
multiple interpretation of the content, providing a new space of attack vectors.
We characterize of what constitutes a dangerous format in the web setting and
identify particularly dangerous formats, with PDF as the prime example. We
demonstrate that polyglot-based attacks on the web open up for insecure
communication across Internet origins. We perform a systematic study of
PDF-based injection and content repurposing attacks. We evaluate the current
practice in client/server content filtering and PDF readers for polyglot-based
attacks, and report on vulnerabilities in the top 100 Alexa web sites. Our
recommendations for protective measures on server side, in browsers, and in content
interpreters (such as PDF readers) show how to mitigate the attacks.
\end{abstract}


\begin{IEEEkeywords}
Web Security; Polyglot; Injection; Cross-domain.
\end{IEEEkeywords}








%1 pages
\section{Introduction}
\label{sec:intro}

General introduction for web application security.

The following attacks have been particularly successful (support with
references).

\subsection{Injection attacks}

Injection attacks have gone from classical to sophisticated.

New breed of attacks.

\subsection{Content repurposing attacks}

Server side verification

Examples


Bridge to the next section saying that we take these attacks to the next level.

%3 pages
\section{Crossing origins by crossing formats}

% Describe how the attacks lead to Same-Origin Policy bypass.

This section describes how formats can be crossed and how that can be abused 
to cross origins by circumventing the \emph{Same-Origin Policy}. We begin by 
generalizing the problem of crossing formats to \emph{polyglots} and then describe the  
characteristics of a malicious polyglot. From that we derive two attack vectors and 
show how previous work on the subject relate to these vectors.

\subsection{Crossing origins}

By crossing origins we mean being able to request and access content
which is normally restricted under the Same-Origin Policy (SOP). 
The SOP dictates that a two document can only access each others 
content and resources if they share the same origin. Similarly this applies to communication as 
well; a document can only directly communicate with the server from which it originated. 
This is not to be confused with Cross-Origin Resource Sharing (CORS), which is an 
intentional relaxing of the SOP.

While there are exceptions to this policy, e.g. images, scripts, and style sheets 
are allowed to be included as resources across origins, access to these resources is 
carefully restricted to prevent information leaks. As an example, the including 
document is prevented from accessing the image data of images loaded across 
origins. 

Not all elements are as carefully restricted from information leaks as images. 
Scripts loaded across origins become part of the document and inherit the 
origin of the including document, which allows the script to communicate with the 
server from which the \emph{document} originated. Such scripts are also able to interact 
with the document, e.g. by adding nodes, which in turn require new content to be 
requested. Since these requests are not restricted by the SOP, this creates a side 
channel that permits cross-origin information leakage. At the same time, the including document
is prevented from inspecting the source of the script and can only observe the public 
side-effects that the script produce as it is executed.

Other examples of problematic elements include the object- and embed-tags. These 
tags allow inclusion of resources that might require a 
plug-in to run. As with images, the content handled by the plug-in retains its origin, 
but the browsers are forced to rely on the plug-ins to employ correct security 
measures to prevent information leaks. While the containing page is restricted 
from directly accessing the content handled by the plug-in, a number of plugins provide 
an API for interacting with the plug-in and the data. As we will show, this can easily lead to 
to cross-origin information leaks.

\subsection{Crossing formats}

% What and how?

A polyglot is defined as ``A person who knows several languages.'', and the term
is widely used in various fields of science. In computer science, a polyglot is
a program that is valid in multiple programming languages. In this paper we use
a broader definition of a programming language, not limited to code meant for
compilation to machine code or scripting languages, but extended to any format
that requires interpretation before rendering.

A polyglot is composed from various constructs that are either common between
languages; or constructs that are language specific, but carrying different
meaning in each language. To maintain validity across languages, one must ensure
that language specific constructs are not interpreted by other languages. This
is often accomplished by hiding the parts of the code specific to one language,
in parts interpreted as comments or plain text of another.

Certain languages are particularly suitable for creating polyglots. These
languages either have a lot of constructs in common with other languages, such
as \emph{C}, or are defined such that the parser ignores that which it cannot
interpret, such as \emph{HTML}. The latter allows for ample opportunity to hide
any code specific to another language, as long as there is no overlap with the
syntax of the first language.


\paragraph{Malicious polyglots}

% What is a malicious polyglot? - One part benign one part malicious

A malicious polyglot is composed of two formats where one is benign in nature and the other
contains a malicious payload. 
% Characteristics of a malicious polyglot
The benign format would preferably be a widely accepted format with the capability 
of hiding arbitrary data, e.g. an image with comment fields. The malicious file 
format would ideally have strong capabilities, s
% Under what circumstances can a polyglot be malicious
This kind of polyglot can be used for malicious purposes when there is a difference between
the expected run-time context and the actual context it is executed in. 
In the expected context the content would be interpreted as the 
benign format. In the actual context, however, the content is coerced to be 
interpreted as the malicious format containing the payload.

Even if a verification process exists, it would verify that the content is valid 
in the expected context. Due to the nature of the polyglot, the content would be 
verified as valid and benign, but subsequently the malicious
content is executed.

In a web context, coercing content to be interpreted as a different type be 
done easily. If the content is loaded using an image-tag it will be interpreted 
as an image, if a script-tag is used it will be interpreted as a script. Some 
tags even let the developer decide which type to interpret the content as. 
To prevent abuse, the browsers employ content-type 
sniffing for certain content-types, a practice which has historically led to 
security issues.


% Malicious polyglots in literature; gifar, chameleon, cross-origin css attacks

We have identified two vectors in which malicious polyglots can be used for 
exploitation; syntax injection, and content repurposing.


%It is possible to create such a polyglot by mixing content, that is benign when
%verified, with content, that is malicious when executed. The verification
%process will see the benign content and allow it

%In literature we find Content repurposing, content smuggling, chameleon, gifar



\subsection{Syntax injection}

% Description of attack technique

In a cross-site scripting attack, HTML syntax is injected into a preexisting
HTML document via vulnerable user supplied parameters. Similarly, a syntax
injection attack consists of injecting foreign syntax into preexisting content
of a different format, thereby creating a polyglot. The polyglot content can
then be interpreted as either format; the benign original format, or the
malicious user-supplied format.

% Attack building blocks

% Browser, plug-in/content handler, target, vulnerability, server


The target in this scenario is a user of the vulnerable website. The polyglot is
served in the benign format on the vulnerable server. While the user is logged in to
the service that the vulnerable website provides, the user unsuspectingly visits
the attackers malicious website. The page embeds the polyglot content, but
coerces the browser to interpret the content as the malicious format. 
How  on the capabilities of the malicious format, 
The attacker can now
exploit the vulnerability, either by making requests to the vulnerable website
in the context of the user; or by extracting information about the user that is
stored on the vulnerable website.

In situations like these, the same-origin policy is intended to prevent a
document from one origin from accessing the content of a document of another
origin. However, depending on the capabilities of the malicious format used in
the attack, it may be possible to circumvent the same-origin policy.

For this attack to be successful certain requirements needs to be fulfilled.
\begin{itemize} 
	\item The original content must embed external information under the 
	control of the attacker. 
	\item The user-supplied content must circumvent any validation or 
	filtering. 
	\item There must exist a way of coercing the resulting polyglot to be 
	interpreted as the malicious format. 
	\item The malicious format must have capabilities that are restricted or 
	missing in the benign format.
\end{itemize}

% Scenarios

%Much like a cross-site scripting attack, we consider a scenario where a
%website serves documents which are based upon user-supplied information.

%The same-origin policy is intended to prevent a document from one origin from
%accessing the content of a document of another origin. 
As an example the
same-origin policy allows a script-tag in one document to include JavaScript of
another origin and execute it in the context of that document. If an attacker is
able to inject an HTML document with JavaScript syntax in such a way that it
became valid JavaScript, the attacker could include the document across origins
via a script-tag and extract its content, thereby circumventing the same-origin
policy.

%Consider the php-program in listing \ref{lst:php-sample}. Apart from being
%vulnerable to traditional cross-site scripting, it is vulnerable

%By requesting the site with parameter $guess=</body></html>;x=<html><body>$,
%the resulting document, 
The document in listing \ref{lst:html-js}, is both
malformed but valid HTML and valid JavaScript in browsers that support E4X. The
document can be included as a script in another document and the secret can be
extracted from variable x. This implies that if an attacker is able to inject
HTML syntax into a document, such that the result is two balanced E4X trees,
then information can be extracted across origins.

\begin{lstlisting}[label=lst:html-js, caption=HTML / E4X Polyglot]
<html><body>
Hello </body></html>;x=<html><body>!
Your secret is 'safe with me'.
</body></html>
\end{lstlisting}

This attack has been suggested as a potential way to bypass Content Security
Policy~\cite{Heyes:CSP}. As E4X is only supported in the SpiderMonkey JavaScript
engine, used in Firefox, this limits the exploitability of this example. While
this is an unlikely scenario using JavaScript as the injected format, section
\ref{sec:vuln} will show how this can be achieved in practice.





\subsection{Content repurposing}

% Description of attack technique 
A content repurposing attack targets the users of a website
that allows and serves user supplied files. This could be a file sharing
service, an image database, or a job search service. The service would only 
accept a limited set of file-types, and the files are verified to
be of one of these types, e.g. an image, before being served to the end
user. By submitting a polyglot to such a service, an attacker can trick the
service into serving malicious content under the origin of the service. The
service will verify the file, assuming that it is of the benign format, but once
the content is served an attacker can coerce the content to be interpreted as
the malicious format.

% Building blocks

The difference in this scenario from the previous one is in the nature of the
vulnerability. Where in the previous scenario an existing document was injected
to become a polyglot, this scenario targets services which allow an attacker to
introduce new documents. As in the previous scenario, the target is a user of
the vulnerable website.


For this attack to be successful, certain requirements needs to be fulfilled.
\begin{itemize} 
	\item The service must accept and serve user-supplied files.
	\item The service must verify the user-supplied polyglot under the 
	assumption that it is in the benign format. 
	\item The content is served under the same origin as sensitive user 
	information.
	\item There must exist a way of coercing the polyglot to be interpreted 
	as the malicious format. 
\end{itemize}

% Scenarios

%3 pages 
\section{Vulnerabilities}
\label{sec:vuln}

In this section we give concrete examples of the attacks described in the
previous section, using the PDF format as the running example.

\subsection{Concept}


\subsection{The PDF format}

% Why PDF format?

The PDF format is a widely used, text based format with powerful capabilities.
It is capable of displaying text, rendering graphics, animation and dynamic
content. It is a container format which allows for embedding of other files
and formats. This and the fact that it is designed to be robust against errors,
provides us with a format that is powerful, flexible and ideal for creating
malicious polyglots.

% Several design choices 

% - Error tolerant parsing
% - Execute JavaScript
% - Embed flash files
% - Launch commands

Furthermore the PDF format is of particular interest to us because it can
execute JavaScript and send HTTP requests to the server from which the document
originated.

\subsubsection{PDF communication channels}

For communication with the containing page, one can either use
hostContainer.postMessage(info) or app.launchURL('\#'+info). The latter has the
advantage that it works in Firefox which seems to not handle the postMessage
very well.



\subsection{The object-tag}

%The object-tag allows the developer to specify which format 
%the embedded content should be interpreted as.

The object-tag is used to embed content, which requires a browser plug-in
to run, in a web page. The plug-in is selected based on the MIME-type of the content, but
because the server delivering the content might not be able to determine its
format, the object tag allows a developer to set the type-attribute to guide the
browser in which plug-in to run. When the type attribute is used, the
corresponding plug-in is run regardless of which MIME-type the server returns
and it is up to the plug-in to respond to and handle the content it is served.

As it turns out, various browser plug-ins deal with the situation differently. The Chrome browser
built-in PDF reader refuses to render content that was served with an inappropriate 
MIME-type. The Java plug-in used to ignore the MIME-type, but after several 
vulnerabilities were disclosed, this behavior was changed. 

In the case of the Adobe Reader plug-in, it completely disregards the MIME-type
supplied by the server and will attempt to interpret any content as PDF. If the 
Chrome browser is configured to use the Adobe Reader plug-in, the behavior will 
be the same as in other browsers and the content will be interpreted as PDF.



\subsection{Syntax injection}

the minimal malformed structure that is required for Adobe Reader to consider ita PDF.

\begin{lstlisting}[label=lst:minimal-pdf, caption=HTML / E4X Polyglot]
%PDF-
trailer<</Root<</Pages<<>>>>>>
\end{lstlisting}

This means the required tokens that we need to be able to inject are: \%PDF-,
trailer, <<, >> and /. The \%PDF and trailer token is usually no problem. From
what I have seen, sometimes PDF is turned to lower case which prevents the
attacks. Quite naturally, unless the site is vulnerable to traditional XSS, the
<< and >> tokens are usually converted to \&lt; or some other encoding. The
exception is in a JavaScript string context. In this context only </script> pose
a threat, in case the < is not encoded this is usually prevented by escaping the
slash:

var s = 'user string<\\/script>';

This is bad from a PDF syntax point of view, because \\/Root is not valid. But
</script> is only valid when the < is directly followed by /. So we can create a
PoC which is not vulnerable to traditional XSS, where the injection is in a
string and only </ is escaped, which will be vulnerable to PDF injection.


\subsection{Content repurposing}



\subsection{Instances}

How this problem presents itself in various instances of browsers and readers.


\subsubsection{Browsers}

Vulnerable: Firefox, Safari, Opera, Chrome

Not vulnerable: Internet Explorer


\subsubsection{Readers}

Vulnerable: Adobe Reader

Not vulnerable: Chrome PDF-viewer

Not tested: Apple Preview









%3 pages 
\section{Evaluation}

\subsection{Bypassing content filters}


\subsubsection{Server-side upload filters}

Filter can verify that the benign file format is indeed benign without ever
noticing the malicious file format hidden within.


\subsubsection{Cross-site scripting filters}

This effectively bypasses any cross-site scripting filters such as NoScript or
filters built into browsers. Since the Reader plug-in handles the response, the
browser never gets to see the content


\subsubsection{Context sensitive filters}

Clever filters that adapt their filtering to the context in which the user
content is included. Basically filters that allow input that do not form harmfulHTML.


\subsection{Alexa top 100}

Alexa top 100 results

%Baidu.com (allows <>, but escapes /) 
%LinkedIn (allows <>, but escapes /) 
%Soso (allows <>, but escapes /) 
%Youku (vulnerable to traditional XSS) 
%Soku (vulnerable to traditional XSS) 
%alibaba.com (allows <>, but escapes /)
%about.com (vulnerable to traditional XSS,
%http://linux.about.com/sitesearch.htm?q=XSS&SUName=--%3E%3Cimg+src=x+onerror=alert%281%29%3E)
%sogou.com (potential target
%http://www.sogou.com/web?query=%25PDF+%3C%3C+%2F+%3E%3E&_asf=www.sogou.com&_ast=1349689275&w=01019900&p=40040100&sut=11010&sst0=1349689274528)










%1-2 pages 
\section{Mitigation}

This section will describe our recommendations for mitigation in each of the
affected components.

\subsection{Server-side mitigation}

As a content provider on the Internet today there are precautions that one can 
take to mitigate this class of vulnerabilities. Which precautions to take depend 
on the kind of services provided. The mitigation recommendations for syntax 
injection apply to services that rely on user input, and the content repurposing 
recommendations apply to services that serve user-supplied files.

\subsubsection{Syntax injection}

%In the case of PDF; always encode tokens related to the PDF 
%syntax. Generally, hard to ensure that tokens for all potential 
%file formats are properly encoded without breaking anything.

Preventing syntax injection attacks on the server-side poses severe challenges.
Even server-side filtering of HTML syntax to prevent cross-side scripting
attacks has proved difficult due to the many contexts in which JavaScript can be 
introduced. Filtering all potentially harmful tokens from all formats in which a 
document could be interpreted, will likely be near impossible.

To prevent PDF syntax injection attack, the task is simpler. As mentioned in Section~\ref{sec:vuln}, there is a limited 
set of characters that are essential to create valid PDF syntax, namely \emph{'$<$', '$>$', and '/'}. Filtering 
user input to remove or encode these characters effectively mitigates the vulnerability.


\subsubsection{Content repurposing}

The current best-practice recommendation from Google~\cite{Google:ContentHosting} 
on hosting user-supplied content, is to serve the content from an origin that is 
completely separate, and isolated from the sensitive services. It also describes how 
Google moved away from sanitizing content , as it was found to be insufficient in 
many cases.

Google uses the domain name \emph{googleusercontent.com} to sandbox all the 
untrusted user files that their various services provide for their customers.


\subsection{Browser}

Traditionally, browser vendors have allowed the browser to override the 
MIME-type provided by the server for compatibility reasons. This is a compromise 
to deal with the situation that the server is confused as to what kind of content it is serving. This compromise 
has repeatedly shown to lead to security issues. The affected browser vendors 
could help mitigate this problem by limiting the ways content can be coerced to be 
interpreted as a particular format.

In the case of PDF-based polyglots, the browser could intervene when there is a 
mismatch between the content-type provided by the server and the type attribute 
of the object tag. By acknowledging that there could be a potential security issue in 
interpreting the supplied content in the requested format and alerting the user to this
threat, the vulnerability could be mitigated.

One could argue that the browser is as confused as the originating server as to the 
actual format of the content, and that the issue would be best resolved by the 
corresponding plug-in.

\subsection{Interpreter}

As a general rule of thumb, the interpreter at the very least alert the user if the served 
content-type differs from the expected. A preferred alternative would be to 
not attempt to interpret the content at all. This holds true especially when 
the served content-type is well known and radically different from that which 
the interpreter is designed for.

As for the PDF file format, the underlying design decisions has led to the 
current parsing being very relaxed, even with respect to the specification. 
Making the parsing more strict and enforcing many of the specified requirements 
would greatly reduce the attack surface. It is, however, not a complete 
mitigation approach. Since the PDF format is a container format it is designed to 
embed syntax from other files. Even when parsing strictly according to 
the specification, it would be a simple task to create a PDF-based polyglot.




%1 page 
\section{Related work}






%1 page 
\section{Conclusions}
We have put a spotlight on a new breed of attacks that smuggle
malicious payload formatted as benign content. We have identified
polyglots as the root cause for this class of attacks. In a systematic
study, we have characterized the necessary ingredients for
polyglot-based attacks on the web and arrive at the PDF format to be
particularly dangerous. Our empirical studies in the web setting
confirm vulnerabilities in the current content filters both in the
server side and in browsers, as well as in the PDF interpreters.
These vulnerabilities open up for insecure communication across
Internet origins and allow attacking web sites from the top 100 Alexa
list. To mitigate the attacks, we suggest general measures against
polyglot-based attacks.  These measures are a combination of
protection on the server side, in browsers, and in content
interpreters such as PDF readers.

The affected vendors have been made aware of the
vulnerabilities. These vendors include Adobe (notified instantly after
discovering the security implications of polyglot PDFs)
%in late 2009
and the major browser vendors. We have also contacted the vulnerable
web sites from the top 100 Alexa list.

Future work includes identification of further formats vulnerable to
polyglot-based attacks. Versatile media content formats such as the
Windows Media Video format are of particular concern because of their
potential for executing scripts. Further investigation of the PDF
format might lead to enhanced possibilities to bypass content filters
by alternative character sets.

We also plan to extend the empirical study to popular services like
HotCRP, Europass CV, and arXiv.org that allow uploading PDF
documents. Authorization is pending for an in-depth security study of
a major conference submission system.

%1-2 pages 
\bibliographystyle{IEEEtran}
\bibliography{literature}

\end{document}



% The below example is too long and complicated.

%\begin{lstlisting}[label=lst:php-sample,caption=Vulnerable
%PHP-program,captionpos=b] 
%<?php %session_start(); %$_SESSION["secret"] = rand(); 
%?> 
%<html><body> 
%Your guess: <?=$_GET["guess"]?>! 
%The secret is: <?=$_SESSION["secret"]?> 
%</body></html> 
%\end{lstlisting}
%\begin{lstlisting}[label=lst:html-js,caption=Vulnerable
%PHP-program,captionpos=b] 
%<html><body> 
%Your guess:</body></html>;x=<html><body>! 
%The secret is: 521352342 
%</body></html>
%\end{lstlisting} 
%\if 0 
%$ 
%\fi