\documentclass{acm_proc_article-sp}
%\documentclass[10pt, conference, compsocconf]{IEEEtran}

% From ASIACCS'13 CFP
% Submissions must be written in English, and must be at most 10 pages
% excluding the bibliography and well-marked appendices, and at most
% 12 pages overall.

\usepackage{listings}
\usepackage{url}

\usepackage{amssymb}
\usepackage[usenames]{color}
\definecolor{lightred}{rgb}{1,0.8,0.8}
\newcommand{\todo}[1]{\colorbox{red}{\textcolor{white}{\sffamily\bfseries\scriptsize TODO}} \textcolor{red}{#1} \textcolor{red}{$\blacktriangleleft$}}


\title{Crossing Origins by Crossing Formats}

\begin{document}


% \author{\IEEEauthorblockN{Jonas Magazinius} 
% \IEEEauthorblockA{Department ofComputer Science\\ 
% Chalmers University of Technology\\ 
% Gothenburg, Sweden\\
% jonas.magazinius@chalmers.se} 
% \and 
% \IEEEauthorblockN{Billy Rios} 
% \IEEEauthorblockA{dept. name of organization\\ 
% name of organization, acronyms acceptable\\ 
% City, United States of America\\ 
% Email: name@xyz.com} 
% \and 
% \IEEEauthorblockN{Andrei Sabelfeld} 
% \IEEEauthorblockA{Department of Computer Science\\ 
% Chalmers University of Technology\\ 
% Gothenburg, Sweden\\ 
% andrei@chalmers.se} 
% }

\maketitle



\begin{abstract}
 In a heterogeneous system like the web, information is
exchanged between components in versatile formats. A new breed of attacks is on
the rise that exploit the mismatch between the expected and provided content.
% 
This paper identifies the root cause of a large class of attacks: \emph{polyglots}. 
A polyglot is a program that is valid in multiple programming languages. Polyglots allow
multiple interpretation of the content, providing a new space of attack vectors.
%
We characterize of what constitutes a dangerous format in the web setting and
identify particularly dangerous formats, with PDF as the prime example. We
demonstrate that polyglot-based attacks on the web open up for insecure
communication across Internet origins. 
%
The paper presents novel attack vectors that are based on
\emph{syntax injection} that 
operate across multiple languages and on \emph{content repurposing} that supply
malicious payload that appears formatted as benign content. 
%
We perform a systematic study of
PDF-based injection and content repurposing attacks. We evaluate the current
practice in client/server content filtering and PDF readers for polyglot-based
attacks, and report on vulnerabilities in the top 100 Alexa web sites. Our
recommendations for protective measures on server side, in browsers, and in content
interpreters (such as PDF readers) show how to mitigate the attacks.
\end{abstract}


% \begin{IEEEkeywords}
% Web Security; Polyglot; Injection; Cross-domain.
% \end{IEEEkeywords}








%1 pages
\section{Introduction}
\label{sec:intro}
Web application security is concerned with protecting information as
it is manipulated by web applications. This is an important area
because ``attacks against web
applications constitute more than 60\% of the total attack attempts
observed on the Internet''~\cite{SANS09}.

\paragraph{Internet origins at stake}
The different trust domains
correspond to different Internet origins. A major goal for web
application security is preventing undesired communication across
origins. 
%
With the goal of separating information from the different origins,
today's browsers enforce the \emph{same-origin policy} (SOP). SOP
only allows access between two documents if they share the
origin. In addition, a document can only directly communicate with the
server from which it originates.

\paragraph{Classical cross-domain attacks}
There are several classes of cross-domain attacks that circumvent SOP.
The OWASP top 10 list~\cite{OWASP:top10:2010} places \emph{injection}
and \emph{cross-site scripting} (XSS) attacks as two top security
risks for web applications.
%
A classical XSS attack injects a malicious script in the context of a
trusted origin. This opens up opportunities for leaking sensitive
information that users might have in the context of the trusted origin
such as cookies, personal information, and session tokens.

XSS attacks are relatively well understood by researchers and
developers~\cite{XSSED}. Known defense include various
flavors of \emph{sanitization} on server side and the
\emph{content security policy}~\cite{CSP1.0} (CSP) on client side. Sanitization
is often performed by the server to filter possibly malicious input data
before it is used in the generated web pages. Content security policy puts
requirement on the structure of the document and the origins of the
scripts that are included by web pages.

\paragraph{Crossing origins by crossing formats}
This paper identifies a new breed of attacks and its root cause:
\emph{polyglots}. 
%
A polyglot is a program that is valid in multiple programming languages.
%
In a heterogeneous system like the web, information is exchanged
between components in versatile formats.
%
This gives rise to attacks that exploit the mismatch between the
expected and provided content.
%
The existing defense mechanisms fall short to prevent these attacks
from achieving cross-domain communication.

Polyglots allow
multiple interpretation of the content, providing a new space of attack vectors.
We present novel attack vectors that are based on (i)
\emph{syntax injection} that 
operate across multiple languages and on (ii) \emph{content repurposing} that supply
malicious payload that appears formatted as benign content. 

\todo{Say why sanitization and CSP are of no use}

\todo{Mention GIFAR and perhaps other profile examples and say we're
  the first to perform a systematic study}

We characterize of what constitutes a dangerous format in the web setting and
identify particularly dangerous formats, with PDF as the prime example. We
demonstrate that polyglot-based attacks on the web open up for insecure
communication across Internet origins. We perform a systematic study of
PDF-based injection and content repurposing attacks. 


\paragraph{Evaluation and mitigation}
We evaluate the current
practice in client/server content filtering and PDF readers for polyglot-based
attacks, and report on vulnerabilities in the top 100 Alexa web sites. Our
recommendations for protective measures on server side, in browsers, and in content
interpreters (such as PDF readers) show how to mitigate the attacks.

\paragraph{Contributions} The paper makes the following contributions:
\begin{itemize}
\vspace*{-.6cm}
\item We identify polyglot attacks, a new breed of attacks for
  crossing origins by crossing formats;
\vspace*{-.2cm}
\item We characterize the necessary ingredients for polyglot attacks
\vspace*{-.2cm}
\item We arrive at the PDF format as a particularly exposed format for
  polyglot-based attacks;
\vspace*{-.2cm}
\item We present two novel attack vectors, based on syntax and
  injection and content repurposing;
\vspace*{-.2cm}
\item We evaluate the current filtering mechanisms, browsers, and PDF
  filters for vulnerabilities; and
\vspace*{-.2cm}
\item We propose mitigation for the server, client, and PDF readers.
\end{itemize}


\paragraph{Overview}
The paper is organized as follows. 
%
Section~\ref{sec:cross} explains the concept of crossing origins by
crossing formats, identifies necessary ingredients, and provides
attack scenarios.
%
Section~\ref{sec:vuln} focuses on the PDF format and describes
concrete vulnerabilities and attacks.
%
Section~\ref{sec:eval} evaluates the current practice in client/server
content filtering and PDF readers and report on vulnerabilities in the
top 100 Alexa web sites.
%
Section~\ref{sec:mit} suggests mitigation for servers, clients, and
PDF readers.
%
Section~\ref{sec:related} discusses the related work.
%
Section~\ref{sec:conc} concludes and outlines future work.

%3 pages
\section{Crossing origins by crossing formats}
\label{sec:cross}
% Describe how the attacks lead to same-origin policy bypass.

This section describes how formats can be crossed and how that can be abused 
to cross origins by circumventing the same-origin policy. We begin by 
generalizing the problem of crossing formats to \emph{polyglots} and then describe the  
characteristics of a malicious polyglot. From that we derive two attack vectors and 
show how previous work on the subject relate to these vectors.

\subsection{Crossing origins}
\label{sec:cross-origin}

By crossing origins we mean being able to request and access content
which is normally restricted under the same-origin policy. 
Recall that SOP only allows two documents accessing each others'
content and resources if they share the origin. Similarly,
a document can only directly communicate with the server from which it originates. 
This is not to be confused with \emph{cross-origin resource sharing} (CORS)~\cite{w3-cors}, which is an 
intentional relaxation of SOP.

While there are exceptions to this policy, e.g. images, scripts, and style sheets 
are allowed to be included as resources across origins, access to these resources is 
restricted to prevent information leaks. As an example, the including 
document is prevented from accessing the image data of images loaded across 
origins. 

Not all elements are as carefully restricted from information leaks as images. 
Scripts loaded across origins become part of the document and inherit the 
origin of the including document, which allows the script to communicate with the 
server from which the \emph{document} originates. Such scripts are also able to interact 
with the document, e.g. by adding nodes, which in turn require new content to be 
requested. Since these requests are not restricted by SOP, this creates a side 
channel that permits cross-origin information leakage. At the same time, the including document
is prevented from inspecting the source of the script and can only observe the public 
side-effects that the script produce as it is executed.

Other examples of problematic elements include the \emph{object} and
\emph{embed} tags. These 
tags allow inclusion of resources that might require a 
plug-in to run. As with images, the content handled by the plug-in retains its origin, 
but the browsers are forced to rely on the plug-ins to employ correct security 
measures to prevent information leaks. The plug-in is selected based on the MIME-type of the content, but
because the server delivering the content might not be able to determine its
format, the \emph{object} tag allows a developer to set the type-attribute to guide the
browser in which plug-in to run. When the type attribute is used, the
corresponding plug-in is run regardless of which MIME-type the server returns
and it is up to the plug-in to respond to and handle the content it is served. While the containing page is restricted 
from directly accessing the content handled by the plug-in, a number of plugins provide 
an API for interacting with the plug-in and the data. As we will show, this can lead to 
to cross-origin information leaks.


\subsection{Crossing formats}

% What and how?

A polyglot is perhaps most commonly known as a person who speaks several
languages. However, the term
is widely used in several scientific fields. In computer science, a \emph{polyglot} is
a program that is valid in multiple programming languages. In this paper we use
a broader definition of a programming language, not limited to code meant for
compilation to machine code or scripting languages, but extended to any format
that requires interpretation before rendering.

A polyglot is composed from various constructs that are either common between
languages; or constructs that are language specific, but carrying different
meaning in each language. To maintain validity across languages, one must ensure
that language specific constructs are not interpreted by other languages. This
is often accomplished by hiding the parts of the code specific to one language,
in parts interpreted as comments or plain text of another.

Certain languages are particularly suitable for creating polyglots. These
languages either have a lot of constructs in common with other languages, such
as the C language, or are defined such that the parser ignores that which it cannot
interpret, such as HTML. The latter allows for ample opportunity to hide
any code specific to another language, as long as there is no overlap with the
syntax of the first language.


%\paragraph{Malicious polyglots}

% What is a malicious polyglot? - One part benign one part malicious

A malicious polyglot is composed of two formats where one is benign in nature and the other
contains a malicious payload. 
% Characteristics of a malicious polyglot
The benign format is a widely accepted format with the capability 
of hiding arbitrary data, e.g. an image with comment fields. The malicious 
format has additional capabilities, such as scripting.
% Under what circumstances can a polyglot be malicious
This kind of polyglot can be used for malicious purposes when there is a difference between
the expected run-time context and the actual context it is executed in. 
In the expected context the content is interpreted as the 
benign format. In the actual context, however, the content is coerced to be 
interpreted as the malicious format containing the payload.

Even if a verification process exists, it verifies that the content is valid 
in the expected context. Due to the nature of the polyglot, the content is 
verified as valid and benign, but subsequently the malicious
content is executed.

Coercing content to be interpreted
as a different type can be accommodated in the context of the web. 
If the content is loaded using an \emph{image} tag it will be interpreted 
as an image, if a \emph{script} tag is used it will be interpreted as a script. Some 
tags even let the developer decide which type to interpret the content as. 
To prevent abuse, the browsers employ content-type 
sniffing for certain content-types, a practice which has historically led to 
security issues.
\todo{explain the issues and cite Barth et al.~\cite{Barth+:SP09}}

% Malicious polyglots in literature; gifar, chameleon, cross-origin css attacks

We have identified two vectors in which malicious polyglots can be used for 
exploitation: syntax injection and content repurposing.


%It is possible to create such a polyglot by mixing content, that is benign when
%verified, with content, that is malicious when executed. The verification
%process will see the benign content and allow it

\todo{
In literature we find Content repurposing, content smuggling,
chameleon, gifar; say that we have called it content smuggling
ourselves in case someone discovers the blog
}


\subsection{Syntax injection}

% Description of attack technique

In a cross-site scripting attack, HTML syntax is injected into a preexisting
HTML document via vulnerable user supplied parameters. Similarly, a syntax
injection attack consists of injecting foreign syntax into preexisting content
of a different format, thereby creating a polyglot. The polyglot content can
then be interpreted as either the benign original format or the
malicious user-supplied format.

% Attack building blocks

% Browser, plug-in/content handler, target, vulnerability, server

\todo{diagram with attack scenario. for example: with example domains attacker.com and
  vulnerable.com leaking secret file secret.txt}
The target in this scenario is a user of the vulnerable website. The polyglot is
served in the benign format on the vulnerable server. While the user is logged in to
the service that the vulnerable website provides, the user unsuspectingly visits
the attackers malicious website. The page embeds the polyglot content, but
coerces the browser to interpret the content as the malicious format. 
The capabilities of the malicious format determine the severity of the consequences.
The attacker can
exploit the vulnerability, either by making requests to the vulnerable website
in the context of the user; or by extracting information about the user that is
stored on the vulnerable website.

In situations like these, the same-origin policy is intended to prevent a
document from one origin from accessing the content of a document of another
origin. However, depending on the capabilities of the malicious format used in
the attack, it may be possible to circumvent the same-origin policy.

For this attack to be successful certain requirements needs to be fulfilled.
\begin{itemize} 
	\item The original content must embed external information under the 
	control of the attacker. 
	\item The user-supplied content must circumvent any validation or 
	filtering. 
	\item There must exist a way of coercing the resulting polyglot to be 
	interpreted as the malicious format. 
	\item The malicious format must have capabilities that are restricted or 
	missing in the benign format.
\end{itemize}

% Scenarios

%Much like a cross-site scripting attack, we consider a scenario where a
%website serves documents which are based upon user-supplied information.

%The same-origin policy is intended to prevent a document from one origin from
%accessing the content of a document of another origin. 
As an example the
same-origin policy allows a \emph{script} tag in one document to include JavaScript of
another origin and execute it in the context of that document. If an attacker is
able to inject an HTML document with JavaScript syntax in such a way that it
became valid JavaScript, the attacker can include the document across origins
via a \emph{script} tag and extract its content, thereby circumventing the same-origin
policy.

%Consider the php-program in listing \ref{lst:php-sample}. Apart from being
%vulnerable to traditional cross-site scripting, it is vulnerable

%By requesting the site with parameter $guess=</body></html>;x=<html><body>$,
%the resulting document, 
The document in Listing \ref{lst:html-js}, is both
malformed but valid HTML and valid JavaScript in browsers that support
EcmaScript for XML (E4X). \todo{ref}

The
document can be included as a script in another document and the secret can be
extracted from variable x. 
This implies that if an attacker is able to inject
HTML syntax into a document, closing all previously open tags and
opening all subsequently closed tags,
then information can be extracted across origins.
The injected HTML in the listing is illustrated by highlighting.

\definecolor{lightgray}{gray}{.8}
\begin{lstlisting}[label=lst:html-js, caption=HTML / E4X Polyglot, escapechar=*]
<html><body>
Hello *\colorbox{lightgray}{$<$/body$><$/html$>$;x=$<$html$><$body$>$}*!
Your secret is 'safe with me'.
</body></html>
\end{lstlisting}

This attack has been suggested as a potential way to bypass Content Security
Policy~\cite{Heyes:CSP}. As E4X is only supported in the SpiderMonkey JavaScript
engine, used in Firefox, this limits the exploitability of this example. However,
this is an unlikely scenario to use JavaScript as the injected format
because HTML characters are typically escaped by content
filters. 
Instead,
Section
\ref{sec:vuln} will show practical attacks based on other formats.

\todo{
Mention and explain known attack instances.
To what extent known attacks such as GIFAR follow this. if not
  we should still mention them}

\subsection{Content repurposing}
\todo{diagram with attack scenario. for example: with example domains attacker.com and
  vulnerable.com leaking secret file secret.txt}
% Description of attack technique 
A content repurposing attack targets the users of a website
that allows and serves user supplied files. Examples are a file sharing
service, an image database, or a job search service. Such a service 
accepts a limited set of file-types, and the files are verified to
be of one of these types, e.g. an image, before being served to the end
user. By submitting a polyglot to such a service, an attacker can trick the
service into serving malicious content under the origin of the service. The
service will verify the file, assuming that it is of the benign format, but once
the content is served an attacker can coerce the content to be interpreted as
the malicious format.

% Building blocks

The difference in this scenario from the previous one is in the nature of the
vulnerability. Where in the previous scenario an existing document was injected
to become a polyglot, this scenario targets services which allow an attacker to
introduce new documents. As in the previous scenario, the target is a user of
the vulnerable website.


For this attack to be successful, certain requirements needs to be fulfilled.
\begin{itemize} 
	\item The service must accept and serve user-supplied files.
	\item The service must verify the user-supplied polyglot under the 
	assumption that it is in the benign format. 
	\item The content is served under the same origin as sensitive user 
	information.
	\item There must exist a way of coercing the polyglot to be interpreted 
	as the malicious format. 
\end{itemize}

% Scenarios
\todo{
Mention and explain known attack instances.
To what extent known attacks such as GIFAR follow this. if not
  we should still mention them}


%3 pages 
\section{Vulnerabilities and attacks}
\label{sec:vuln}

In this section we give concrete examples of the attacks described in 
Section~\ref{sec:cross}, using the PDF format as the running example. We begin
by detailing how the design decision made in the PDF-standard make it 
highly suitable
for creating malicious polyglots.

%\subsection{Concept}


\subsection{Portable Document Format}
\label{sec:format}
% Why PDF format?

The \emph{Portable Document Format} (PDF) is a widely used document format 
capable of displaying text, rendering graphics, scripting, animation and other 
dynamic content. It is a container format in the sense that it allows 
embedding of files and resources.

According to the PDF specification \todo{cite specification} a PDF file is composed of
a header, several objects, a cross-reference section and a trailer. Listing~\ref{lst:sample-pdf} 
shows a sample of how a PDF file is structured and its elements.

\begin{lstlisting}[label=lst:sample-pdf, caption=Sample PDF file]
%PDF-1.7
1 0 obj<</Type/Catalog/Pages<<>>>>
endobj
2 0 obj<</Length 13>>stream
Sample Author
endstream
endobj
xref
0 3
0000000000 65536 f
0000000009 00000 n
0000000057 00000 n
trailer<</Root 1 0 R
	/Info<</Author 2 0 R>>
>>
startxref
118
%%EOF
\end{lstlisting}


% header
\subsubsection{Header}
The header consists of the string "\%PDF-" followed by a version number. 
The version is denoted by a 
major and a minor version number of the form "\emph{M.m}". Because the version can 
be specified elsewhere, the version number is not required to be part of the 
header.

% objects
\subsubsection{Objects}
Objects can be direct or indirect, the difference being that indirect objects 
has labels which are used for referring to the object from another object. Object 
labels are numbered and begin with the string "\emph{N n} obj", where "N" is the object number and "n" is the 
revision number. Similarly object references are of the form "\emph{N n} R".
The label is optionally ended with the keyword "endobj".

There are eight basic types of basic objects; booleans, integers, strings, names, 
arrays, dictionaries, streams and the null object. For the intents and purposes 
of this article, we will focus on the string, dictionary, name and stream objects.

% string objects
\paragraph{String objects}
There are two types of strings; literal and hexadecimal. Literal strings are 
enclosed by the "(" and ")" characters. Any character can occur in a literal 
string, even parentheses if they are balanced, e.g. a matching closing 
parenthesis for every opened parenthesis. In hexadecimal strings 
each character is represented by its corresponding hexadecimal value, enclosed 
by the "$<$" and "$>$" characters.

% dictionary objects
\paragraph{Dictionary objects}
Dictionary objects are a name-value map delimited by the "$<<$" and "$>>$" 
tokens. The names are name objects and the values are objects of any type.
% name objects
Name objects begin with the "/" character, followed by a string of non-whitespace 
characters. Each dictionary has a type, either specified by the "/Type" name or inferred 
from the context in which it occurs. The type declares which kind of element the 
dictionary is describing, e.g. a page or an annotation. Dictionaries form the structure of the document by connecting
objects through references, e.g. relating a page to its contents. %At least one 
%dictionary is required to build a PDF document. 
% actions?
A special type of dictionary describes \emph{actions}. Actions are triggered when a
certain event occur, such as a file is opened or a page is displayed, and the action 
dictionary specify how it should be handled. Actions can be used to, among other 
things, go to a specific page, play a sound, execute JavaScript or launch a command.

% stream objects
\paragraph{Stream objects}
A stream is an unlimited sequence of bytes. A stream object consists of a 
dictionary, describing the stream, and the associated stream delimited by the 
"stream" and "endstream" keywords. PDF supports encoding of streams, in which
case the dictionary describe which filters are required to decode the stream. 

% cross-reference
\subsubsection{Cross-reference}
The cross-reference section is a record of the location of indirect objects 
within a file. The location is specified as the byte offset from the beginning 
of the file. The cross-reference section is opened with the "xref" keyword,
followed by one record for each indirect object. The cross-reference section 
will be reconstructed if missing and can therefore be omitted.

% trailer
\subsubsection{Trailer}
The trailer is composed of a trailer dictionary, a pointer to the cross-reference 
section and an end-of-file marker. The trailer dictionary is introduced by the 
"trailer" keyword. It contains among other things a reference to the root of the 
document structure. The "startxref" keyword is followed by the number of bytes from 
the beginning of the file to the first cross-reference section. As with the 
cross-reference section, it can be omitted. The string "\%\%EOF" marks the 
end-of-file, but can be omitted.


\subsection{PDF-based polyglots}
Several design choices in the PDF specification make the format particularly 
suitable for making polyglots. One such design choice is the error tolerant 
parser. This is in part motivated it being a container format, of which the 
implication is that a PDF file can, by design, contain foreign syntax that 
could interfere with the syntax of the file. Another motivation is that PDF 
files are designed to be both forward- and backward-compatible. Readers 
implementing an older version of the specification do not recognize new 
features and behave as if they were not present in the file. 
%
The implementation notes of the specification describes some exceptions to the
requirements of the specification, such as the header can occur 
anywhere within the first 1024 bytes of the file. This flexibility gives plenty of room for 
combining with syntax of another format.
%
The specification declares many components to be required in a
PDF file, but as can be seen in Section~\ref{sec:format}, in practice several 
components can be omitted. The code in Listing~\ref{lst:minimal-pdf} shows the 
minimal syntax required for a malformed, but valid PDF file.\todo{cite Julia Wolf?}
%incrementally 
%updated by appending updated versions of existing objects to 
%the end of the file. In fact, 
%and formats. This and the fact that it is designed to be robust against errors,
%provides us with a format that is powerful, flexible and ideal for creating
%malicious polyglots.

% - Execute JavaScript
% - Embed flash files
% - Launch commands
% - Network requests

Furthermore the PDF format is of particular interest to us because of its 
many capabilities. Some examples include executing JavaScript, launching commands, 
and issuing HTTP requests. Adobe Reader even includes a flash 
player to play embedded flash files on systems that do
not have a player installed. %Considering that it might be a conscious decision
%of the user to refuse a flash player, 

\begin{lstlisting}[label=lst:minimal-pdf, caption=Minimal PDF file]
%PDF-
trailer<</Root<</Pages<<>>>>>>
\end{lstlisting}


\subsection{Embedded PDF documents}
\todo{Not sure how well it fits here}
When a PDF document is embedded in a web page, the corresponding plugin 
is executed to render the content. Recall from Section~\ref{sec:cross-origin} 
that the plug-in is selected based 
on the MIME-type, either supplied by the server or in the type attribute, and 
that the browser rely on the plug-in to handle the situation when the MIME-type 
supplied by the server is in appropriate for the plug-in.
In the case of the Adobe Reader plug-in, it disregards the MIME-type
supplied by the server and will attempt to interpret any content as PDF. 



\subsection{PDF communication methods}

The embedded document will retain the origin from which it was served. Any 
request issued from the document will include any cookies available in the 
browser for the target domain. This provides an attacker with the means to 
perform actions in the name of an authenticated victim, i.e. Cross-Site Request 
Forgery (CSRF). If the attacker can extract information, such as a CSRF-token, 
the protection mechanism is defeated. \todo{this is describing another attack scenario, expand?}

When embedded in a web page, many of the PDF communication methods utilize
the underlying browser to make requests by navigating the browser to the target 
URL. This will unload the current page in which the document is embedded. Page 
navigation is allowed wtih respect to SOP, since the response is not visible 
to the document. Such methods can be used in CSRF attacks, but would 
defeat the purpose of requesting information as the document cannot process the 
response.

% Cross-origin leaks
To leak information across origins, a communication channel is 
required between the attacker and the target. PDF provides the necessary means 
to mediate this information leakage. The flow of information can be divided into 
two steps, extracting information from the target and delivering it to the attacker.
Each requiring its own communication methods.


\subsubsection{The target}
There are two methods for a PDF file to communicate with the server it originates from, 
both allowing it to read the response: from JavaScript using XML external entities 
and from an embedded flash file.

\paragraph{XML}
The PDF JavaScript API includes a method to parse an XML document, called 
XMLData.parse. The XML document being processed may rely on external entities, 
which the XML parser will request and include in the document. The request is 
bound to the origin of the document. As the response 
is included in the XML, the result has to be well-formed XML. This puts a 
restriction on the content that can be requested using this method. Considering 
that HTML pages are rarely well-formed this method may be too restricted in practice.
Listing~\ref{lst:xml-pdf} contains an example that uses XML external entities.

\paragraph{Embedded Flash}
The embedded flash file inherits the origin of the document, thus it can 
request and read any document from the originating server. Unlike the XML
method, there is no restrictions on what content can be requested.

\begin{lstlisting}[label=lst:xml-pdf, caption=PDF using XML for communication]
%PDF-
1 0 obj<<>>stream
xml = '<!DOCTYPE foo[<!ENTITY x SYSTEM "'+
	URL+'">]><foo>&x;</foo>'
app.alert(XMLData.parse(xml).saveXML())
endstream
trailer<</Root<</Pages<<>>
    /OpenAction<</S/JavaScript/JS 1 0 R>>
    >>
>>
\end{lstlisting}

\subsubsection{The attacker}
There are a number of ways to communicate with the attacker, either directly 
via the embedding page or through the attackers server. As mentioned previously, 
many methods trigger page navigation in the browser. This will result in a 
noticeable change in the victims browser. While it fulfills the purpose of 
leaking information, an attacker can use more covert methods of communication
to refrain from alerting the victim. 

\paragraph{Fragment identifier}
The methods that navigate the browser can still be used for a somewhat covert 
communication with the attacker. Navigating to the same page with a different 
fragment identifier will not reload the page. Embedding the information in the fragment 
identifier of the URL of the embedding website, creates a one-way communication 
channel from the document to the page. Since the fragment identifier is visible 
in the address field of the browser, an alert user would notice it changing.

\paragraph{PostMessage}
The PDF plugin includes an API for communicating directly with the page in 
which it is embedded. The document can send messages to the page using 
the hostContainer.postMessage method. The page registers a handler to receive 
the event and is also able to post messages back to the document.
This two way communication is not visible to the victim.

\paragraph{Embedded Flash}
Cross-origin communication in Flash is restricted by the same-origin policy,
but also support cross-origin communication via  
CORS. Using CORS, a web server can relax SOP to allow access to specified content.
As mentioned, the embedded Flash file inherits the origin of the document.
However, this is not a restriction, since an attacker can set a cross-origin policy 
that allow the request. This allows for a two way communication that is not 
visible to the victim.


\subsection{Syntax injection}
the minimal malformed structure that is required for Adobe Reader to consider ita PDF.



This means the required tokens that we need to be able to inject are: \%PDF-,
trailer, <<, >> and /. The \%PDF and trailer token is usually no problem. From
what I have seen, sometimes PDF is turned to lower case which prevents the
attacks. Quite naturally, unless the site is vulnerable to traditional XSS, the
<< and >> tokens are usually converted to \&lt; or some other encoding. The
exception is in a JavaScript string context. In this context only </script> pose
a threat, in case the < is not encoded this is usually prevented by escaping the
slash:

var s = 'user string</script>';

This is bad from a PDF syntax point of view, because \\/Root is not valid. But
</script> is only valid when the < is directly followed by /. So we can create a
PoC which is not vulnerable to traditional XSS, where the injection is in a
string and only </ is escaped, which will be vulnerable to PDF injection.


\subsection{Content repurposing}










%3 pages 
\section{Evaluation}
\label{sec:eval}

\subsection{Instances}

How this problem presents itself in various instances of browsers and readers.


\subsubsection{Browsers}

Vulnerable: Firefox, Safari, Opera, Chrome

Not vulnerable: Internet Explorer


\subsubsection{Readers}

\todo{see if this makes sense here}
As it turns out, various browser plug-ins deal with the situation differently. The Chrome browser
built-in PDF reader refuses to render content that was served with an inappropriate 
MIME-type. If the 
Chrome browser is configured to use the Adobe Reader plug-in, the behavior will 
be the same as in other browsers and the content will be interpreted as PDF.
The Java plug-in used to ignore the MIME-type, but after several 
vulnerabilities were disclosed, this behavior was changed. 

Vulnerable: Adobe Reader

Not vulnerable: Chrome PDF-viewer

Not tested: Apple Preview


\subsection{Bypassing content filters}


\subsubsection{Server-side upload filters}

Filter can verify that the benign file format is indeed benign without ever
noticing the malicious file format hidden within.


\subsubsection{Cross-site scripting filters}

This effectively bypasses any cross-site scripting filters such as NoScript or
filters built into browsers. Since the Reader plug-in handles the response, the
browser never gets to see the content


\subsubsection{Context sensitive filters}

Clever filters that adapt their filtering to the context in which the user
content is included. Basically filters that allow input that do not form harmfulHTML.


\subsection{Alexa top 100}

Alexa top 100 results

%Baidu.com (allows <>, but escapes /) 
%LinkedIn (allows <>, but escapes /) 
%Soso (allows <>, but escapes /) 
%Youku (vulnerable to traditional XSS) 
%Soku (vulnerable to traditional XSS) 
%alibaba.com (allows <>, but escapes /)
%about.com (vulnerable to traditional XSS,
%http://linux.about.com/sitesearch.htm?q=XSS&SUName=--%3E%3Cimg+src=x+onerror=alert%281%29%3E)
%sogou.com (potential target
%http://www.sogou.com/web?query=%25PDF+%3C%3C+%2F+%3E%3E&_asf=www.sogou.com&_ast=1349689275&w=01019900&p=40040100&sut=11010&sst0=1349689274528)










%1-2 pages 
\section{Mitigation}
\label{sec:mit}
This section will describe our recommendations for mitigation in each of the
affected components.

\subsection{Server-side mitigation}

As a content provider on the Internet today there are precautions that one can 
take to mitigate this class of vulnerabilities. Which precautions to take depend 
on the kind of services provided. The mitigation recommendations for syntax 
injection apply to services that rely on user input, and the content repurposing 
recommendations apply to services that serve user-supplied files.

\subsubsection{Syntax injection}

%In the case of PDF; always encode tokens related to the PDF 
%syntax. Generally, hard to ensure that tokens for all potential 
%file formats are properly encoded without breaking anything.

Preventing syntax injection attacks on the server-side poses severe challenges.
Even server-side filtering of HTML syntax to prevent cross-side scripting
attacks has proved difficult due to the many contexts in which JavaScript can be 
introduced. Filtering all potentially harmful tokens from all formats in which a 
document may be interpreted is hardly possible.

To prevent PDF syntax injection attack, the task is simpler. As mentioned in Section~\ref{sec:vuln}, there is a limited 
set of characters that are essential to create valid PDF syntax, namely \emph{'$<$', '$>$', and '/'}. Filtering 
user input to remove or encode these characters effectively mitigates the vulnerability.


\subsubsection{Content repurposing}

The current best-practice recommendation from Google~\cite{Google:ContentHosting} 
on hosting user-supplied content, is to serve the content from an origin that is 
completely separate, and isolated from the sensitive services. It also describes how 
Google moved away from sanitizing content , as it was found to be insufficient in 
many cases.

Google uses the domain name \emph{googleusercontent.com} to sandbox all the 
untrusted user files that their various services provide for their customers.


\subsection{Browser}

Traditionally, browser vendors have allowed the browser to override the 
MIME-type provided by the server for compatibility reasons. This is a compromise 
to deal with the situation that the server is confused as to what kind of content it is serving. This compromise 
has repeatedly shown to lead to security issues. The affected browser vendors 
can help mitigate this problem by limiting the ways content can be coerced to be 
interpreted as a particular format.

In the case of PDF-based polyglots, the browser can intervene when there is a 
mismatch between the content-type provided by the server and the type attribute 
of the \emph{object} tag. By acknowledging that there can be a potential security issue in 
interpreting the supplied content in the requested format and alerting the user to this
threat, the vulnerability can be mitigated.

One may argue that the browser is as confused as the originating server as to the 
actual format of the content, and that the issue would be best resolved by the 
corresponding plug-in.

\subsection{Interpreter}

As a general rule of thumb, the interpreter at the very least alert the user if the served 
content-type differs from the expected. A preferred alternative is to 
not attempt to interpret the content at all. This holds true especially when 
the served content-type is well known and radically different from that which 
the interpreter is designed for.

As for the PDF file format, the underlying design decisions have led to the 
current parsing being very relaxed, even with respect to the specification. 
Making the parsing more strict and enforcing many of the specified requirements 
will reduce the attack surface. It is, however, not sufficient for complete 
mitigation because the PDF format is a container format it is designed to 
embed syntax from other files. Even when parsing strictly according to 
the specification, it is a simple task to create a PDF-based polyglot.




%1 page 
\section{Related work}
\label{sec:related}
Backes et al.~\cite{Backes+:SP07} explore the power of the PostScript
language. PostScript allows executable content and access to sensitive
information from the environment such as the user id. This work
demonstrates how to compromise reviewer anonymity in a peer-reviewing
process by maliciously crafting a PostScript document.

Nagra~\cite{Nagra:09} demonstrates GIF/JavaScript polyglots by the
same file being interpreted as a script and as an image and
informally discuses possible security implications.

Barth et al.~\cite{Barth+:SP09}

Sundareswaran and Squicciarini~\cite{Sundareswaran:Squicciarini:CEAS10}

Wolf~ OMG WTF PDF talk at CCC in 2010.

%1 page 
\section{Conclusions}
\label{sec:conc}
We have put a spotlight on a new breed of attacks that smuggle
malicious payload formatted as benign content. We have identified
polyglots as the root cause for this class of attacks. In a systematic
study, we have characterized the necessary ingredients for
polyglot-based attacks on the web and arrive at the PDF format to be
particularly dangerous. Our empirical studies in the web setting
confirm vulnerabilities in the current content filters both in the
server side and in browsers, as well as in the PDF interpreters.
These vulnerabilities open up for insecure communication across
Internet origins and allow attacking web sites from the top 100 Alexa
list. To mitigate the attacks, we suggest general measures against
polyglot-based attacks.  These measures are a combination of
protection on the server side, in browsers, and in content
interpreters such as PDF readers.

The affected vendors have been made aware of the
vulnerabilities. These vendors include Adobe (notified instantly after
discovering the security implications of polyglot PDFs)
%in late 2009
and the major browser vendors. We have also contacted the vulnerable
web sites from the top 100 Alexa list.

Future work includes identification of further formats vulnerable to
polyglot-based attacks. Versatile media content formats such as the
Windows Media Video format are of particular concern because of their
potential for executing scripts. Further investigation of the PDF
format might lead to enhanced possibilities to bypass content filters
by alternative character sets.

We also plan to extend the empirical study to popular services like
HotCRP, Europass CV, and arXiv.org that allow uploading PDF
documents. Authorization is pending for an in-depth security study of
a major conference submission system.

%1-2 pages 
\bibliographystyle{plain}
\bibliography{literature}

\newpage
\section*{Todo}
Test page

Billy's and Jonas' anonimized demos?

\end{document}



% The below example is too long and complicated.

%\begin{lstlisting}[label=lst:php-sample,caption=Vulnerable
%PHP-program,captionpos=b] 
%<?php %session_start(); %$_SESSION["secret"] = rand(); 
%?> 
%<html><body> 
%Your guess: <?=$_GET["guess"]?>! 
%The secret is: <?=$_SESSION["secret"]?> 
%</body></html> 
%\end{lstlisting}
%\begin{lstlisting}[label=lst:html-js,caption=Vulnerable
%PHP-program,captionpos=b] 
%<html><body> 
%Your guess:</body></html>;x=<html><body>! 
%The secret is: 521352342 
%</body></html>
%\end{lstlisting} 
%\if 0 
%$ 
%\fi